rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function onlyAllowedKeysChanged(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }
    function isIncrementByOne(field) {
      return request.resource.data[field] == resource.data[field] + 1;
    }
    function isAdmin(uid) {
      return request.auth != null && request.auth.token.admin == true;
    }

    // Dev codes: public read
    match /devCodes/{docId} {
      allow read: if true;
    }

    // Cloudinary credentials: authenticated users can read
    match /imageStorage/{docId} {
      allow read: if request.auth != null;
    }

    // Alternative cloudinary: authenticated users can read
    match /cloudinary/{docId} {
      allow read: if request.auth != null;
    }

    // appUpdates collection
    match /appUpdates/{docId} {
      allow read, write: if request.auth != null;
    }

    // Only feedbacks collection
    match /feedbacks/{docId} {
      allow read, write: if request.auth != null;
    }
    // DevCodes collection
    match /devCodes/{docId} {
      allow read, write: if request.auth != null;
    }
    // Users
    match /users/{uid} {
      // Any signed-in user can read public profile data
      allow read: if request.auth != null;

      // Owner can write their own profile (create/overwrite)
      allow write: if request.auth != null && request.auth.uid == uid;

      // Allow authenticated users to update ONLY followersCount on any user
      allow update: if request.auth != null
                    && onlyAllowedKeysChanged(['followersCount']);

      // Allow ANY authenticated user to block/unblock users by changing
      // only isActive / updatedAt
      allow update: if request.auth != null
                    && onlyAllowedKeysChanged(['isActive', 'updatedAt']);

      // Followers subcollection
      match /followers/{followerId} {
        allow read: if request.auth != null
                    && (
                         request.auth.uid == uid ||
                         request.auth.uid == followerId ||
                         request.auth.uid == resource.data.followerId
                       );

        // Follow: authenticated user creates a doc where id == their uid
        allow create: if request.auth != null
                      && request.auth.uid == followerId
                      && request.resource.data.followerId == request.auth.uid
                      && uid != request.auth.uid;

        // Unfollow: same user deletes their follower doc
        allow delete: if request.auth != null
                      && request.auth.uid == followerId;

        // No updates – only create/delete
        allow update: if false;
      }

      // Following subcollection: who this user follows
      match /following/{targetUserId} {
        // Only the user themselves can read/write their following list
        allow read, write: if request.auth != null
                           && request.auth.uid == uid;
      }

      // Per-user status subcollection
      match /status/{statusId} {
        // Only the user can read their statuses
        allow read: if request.auth != null && request.auth.uid == uid;

        // Any authenticated client can create a status for the user, strict shape
        allow create: if request.auth != null
                      && request.resource.data.keys().hasOnly(
                           ['title','body','images','link','timestamp','isRead']
                         )
                      && request.resource.data.isRead == false
                      && (request.resource.data.images == null || request.resource.data.images is list)
                      && (request.resource.data.link == null || request.resource.data.link is string);

        // isRead can be flipped false -> true without requiring auth;
        // only isRead is allowed to change
        allow update: if onlyAllowedKeysChanged(['isRead'])
                      && resource.data.isRead == false
                      && request.resource.data.isRead == true;

        allow delete: if false;
      }
    }

    // Posts
    match /posts/{postId} {
      // Everyone can read posts
      allow read: if true;

      // Admins can update/delete any post (moderation)
      allow update, delete: if isAdmin(request.auth.uid);

      // Create post: authenticated and author is requester
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Owner can update/delete their post entirely
      allow update, delete: if request.auth != null
                            && resource.data.userId == request.auth.uid;

      // Allow authenticated users to toggle reactions only
      allow update: if request.auth != null
                    && onlyAllowedKeysChanged(['likedBy','dislikedBy','likes','dislikes']);

      // Allow authenticated users to increment replyCount by exactly +1
      allow update: if request.auth != null
                    && onlyAllowedKeysChanged(['replyCount'])
                    && isIncrementByOne('replyCount');

      // Allow authenticated users to vote in polls
      // Constraints:
      // - Only pollCounts and pollVotedBy may change
      // - Poll must not be stopped (cannot vote after stop)
      // - pollOptions must remain unchanged
      // - The voter must not have voted before, and is recorded with an int option index
      // - pollCounts must remain a list with the same length
      allow update: if onlyAllowedKeysChanged(['pollCounts','pollVotedBy'])
                    && ((resource.data.pollStopped == false) || (resource.data.pollStopped == null))
                    && (request.resource.data.pollStopped == false || request.resource.data.pollStopped == null)
                    && request.resource.data.pollOptions == resource.data.pollOptions
                    && (request.auth == null || resource.data.pollVotedBy[request.auth.uid] == null)
                    && (request.auth == null || request.resource.data.pollVotedBy[request.auth.uid] is int)
                    && request.resource.data.pollCounts is list
                    && request.resource.data.pollCounts.size() == resource.data.pollCounts.size();

      // Only post owner can stop a poll (irreversible)
      allow update: if request.auth != null
                    && resource.data.userId == request.auth.uid
                    && onlyAllowedKeysChanged(['pollStopped','pollStoppedAt']);

      // Replies subcollection
      match /replies/{replyId} {
        // Everyone can read replies
        allow read: if true;

        // Create reply: authenticated and author is requester
        allow create: if request.auth != null
                      && request.resource.data.userId == request.auth.uid;

        // Reply owner can update/delete their reply
        allow update, delete: if request.auth != null
                              && resource.data.userId == request.auth.uid;
      }
    }

    // Reports: authenticated create with strict validation; authed read; no update/delete
    match /reports/{reportId} {
      allow create: if request.auth != null
                    && request.resource.data.keys().hasOnly(
                         ['id','postId','reporterId','reporterName','reason','createdAt','status']
                       )
                    && request.resource.data.reporterId == request.auth.uid
                    && request.resource.data.postId is string
                    && request.resource.data.reporterName is string
                    && request.resource.data.reason is string
                    && request.resource.data.status == 'new';

      // Allow reads (for admin UI)
      allow read: if request.auth != null;

      // No client updates/deletes
      allow update, delete: if false;
    }

    // Notifications: very loose – any authenticated user can read/write
    match /notifications/{notificationId} {
      allow read, write: if request.auth != null;
    }

    // Legacy root status: allow any authenticated client to read/write
    match /status/{docId} {
      allow read, write: if request.auth != null;
    }

    // News collection – authenticated users can read and write
    match /news/{newsId} {
      allow read, write: if request.auth != null;
    }

    // App updates and admin notification config
    match /appUpdates/{docId} {
      // Read:
      // - devlink doc public
      // - adminNotificationID only for authenticated users
      allow read: if docId == 'devlink'
                  || (docId == 'adminNotificationID' && request.auth != null);

      // Enable authenticated clients to write the admin OneSignal player id
      allow write: if docId == 'adminNotificationID' && request.auth != null;
    }

    // Conversations (1:1 chats)
    match /conversations/{conversationId} {
      // Allow public read access to conversation metadata (for flexible queries)
      allow read: if true;

      // Create: authenticated, and auth user must be one of the participants
      allow create: if request.auth != null
                    && request.resource.data.participants is list
                    && request.auth.uid in request.resource.data.participants;

      // Updates/deletes: only participants of this conversation
      allow update, delete: if request.auth != null
                            && request.auth.uid in resource.data.participants;

      // Messages subcollection for each conversation
      match /messages/{messageId} {
        // Resolve parent conversation to check participants
        function isParticipant() {
          return request.auth != null
                 && request.auth.uid in get(
                      /databases/$(database)/documents/conversations/$(conversationId)
                    ).data.participants;
        }

        // Participants can read all messages
        allow read: if isParticipant();

        // Participants can send messages where senderId is themselves
        allow create: if isParticipant()
                      && request.resource.data.senderId == request.auth.uid;

        // Participants can update/delete their own messages
        allow update, delete: if isParticipant();
      }
    }

    // Deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}